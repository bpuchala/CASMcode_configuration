#ifndef CASM_basic_symmetry_subgroups
#define CASM_basic_symmetry_subgroups

#include "casm/basic_symmetry/Group.hh"
#include "casm/basic_symmetry/definitions.hh"

namespace CASM {
namespace basic_symmetry {

typedef std::set<Index> SubgroupIndices;
typedef std::set<SubgroupIndices> SubgroupOrbit;

template <typename ElementType>
std::set<SubgroupOrbit> make_cyclic_subgroups(Group<ElementType> const &group);

template <typename ElementType>
std::set<SubgroupOrbit> make_all_subgroups(Group<ElementType> const &group);

}  // namespace basic_symmetry
}  // namespace CASM

// --- Implementation ---

#include <numeric>

namespace CASM {
namespace basic_symmetry {

namespace subgroups_impl {

typedef std::set<Index> CosetIndices;

/// \brief Return the unique left cosets of a subgroup
///
/// - If subgroup B of group G contains elements: (E, B1, B2, …, Bg),
/// the "left coset” of X is (X*E, X*B1, X*B2, …, X*Bg),
/// where X is an element of G.
/// - A coset need not be a subgroup.
/// - If X is an element of B, then the coset will be a subgroup of B.
/// - Two left cosets of a given subgroup either contain exactly the same
/// elements, or have no elements in common.
template <typename ElementType>
std::set<CosetIndices> _make_left_cosets(
    Group<ElementType> const &group, SubgroupIndices const &subgroup_indices) {
  std::set<CosetIndices> left_cosets;

  // each group element is only included in one coset
  std::vector<bool> check(group.element.size(), false);
  Index product_index;
  Index group_element_index = 0;
  while (group_element_index < group.element.size()) {
    if (check[group_element_index]) {
      ++group_element_index;
      continue;
    }
    CosetIndices left_coset;
    for (auto subgroup_element_index : subgroup_indices) {
      product_index = group.multiplication_table[group_element_index]
                                                [subgroup_element_index];
      left_coset.insert(product_index);
      check[product_index] = true;
    }
    left_cosets.insert(left_coset);
    ++group_element_index;
  }
  return left_cosets;
}

template <typename ElementType>
SubgroupOrbit _make_subgroup_orbit(Group<ElementType> const &group,
                                   SubgroupIndices const &subgroup) {
  auto inv = [&](Index i) { return group.inverse_index[i]; };
  auto mult = [&](Index i, Index j) {
    return group.multiplication_table[i][j];
  };

  SubgroupOrbit orbit;
  std::set<subgroups_impl::CosetIndices> left_cosets =
      subgroups_impl::_make_left_cosets(group, subgroup);
  for (auto const &coset : left_cosets) {
    Index X_index = *coset.begin();
    Index X_inv_index = inv(X_index);
    SubgroupIndices equiv_subgroup;
    for (auto const &A_index : subgroup) {
      equiv_subgroup.insert(mult(X_index, mult(A_index, X_inv_index)));
    }
    orbit.insert(equiv_subgroup);
  }
  return orbit;
}

inline std::function<bool(SubgroupIndices const &)> _make_subgroup_count(
    std::set<SubgroupOrbit> const &subgroups) {
  return [&](SubgroupIndices const &subgroup) {
    for (auto const &orbit : subgroups) {
      if (orbit.count(subgroup)) {
        return true;
      }
    }
    return false;
  };
}

template <typename ElementType>
std::function<void(SubgroupIndices &)> _make_close_subgroup(
    Group<ElementType> const &group) {
  return [&](SubgroupIndices &subgroup) {
    std::vector<Index> vgroup(subgroup.begin(), subgroup.end());
    for (Index i = 0; i < vgroup.size(); i++) {
      for (Index j = 0; j < vgroup.size(); j++) {
        Index product_index = group.multiplication_table[vgroup[i]][vgroup[j]];
        if (subgroup.insert(product_index).second) {
          vgroup.push_back(product_index);
        }
      }
    }
  };
}

}  // namespace subgroups_impl

/// \brief Return all subgroups
///
/// - A cyclic subgroup, A, is the subgroup generated by repeated multiplication
/// of a single element, i.e. A={a, a^2, a^3, ..., a^k}, where a^k=E, the
/// identity element
/// - An equivalent subgroup is {X*a*X^-1, X*(a^2)*X^-1, X*(a^3)*X^-1, ..., E},
/// where X is an element in a coset of A
/// - The orbit of a cyclic subgroup is all distinct equivalent subgroups
///
/// \param group The group to find cyclic subgroups of
/// \returns A set of orbits of cyclic subgroups
///
template <typename ElementType>
std::set<SubgroupOrbit> make_cyclic_subgroups(Group<ElementType> const &group) {
  using namespace subgroups_impl;
  auto mult = [&](Index i, Index j) {
    return group.multiplication_table[i][j];
  };

  std::set<SubgroupOrbit> cyclic_subgroups;
  Index group_element_index = 0;
  while (group_element_index < group.element.size()) {
    // Make cyclic subgroup of element `group_element_index`
    SubgroupIndices cyclic_subgroup;
    cyclic_subgroup.insert(group_element_index);
    Index product_index = group_element_index;
    while (product_index != 0) {
      product_index = mult(group_element_index, product_index);
      cyclic_subgroup.insert(product_index);
    }

    // Make orbit of subgroups equivalent to `cyclic_subgroup` && Insert orbit
    cyclic_subgroups.insert(_make_subgroup_orbit(group, cyclic_subgroup));

    ++group_element_index;
  }
  return cyclic_subgroups;
}

/// \brief Return all subgroups
///
/// Method:
/// - Start with m_subgroups = m_small_subgroups, then add new subgroups by
/// finding the closure of a union of a large_group and a small_group.
/// - If the the new large_group is unique, add it as a large_group.
/// - Repeat for all (large_group, small_group) pairs, until no new
/// m_subgroups are found.
///
/// Note:
/// - This is probably not the fastest algorithm, but it is complete
///
/// \param group The group to find subgroups of
/// \returns A set of orbits of all subgroups
///
template <typename ElementType>
std::set<SubgroupOrbit> make_all_subgroups(Group<ElementType> const &group) {
  using namespace subgroups_impl;
  std::set<SubgroupOrbit> small_subgroups = make_cyclic_subgroups(group);
  std::set<SubgroupOrbit> all_subgroups = small_subgroups;

  // functor to close incomplete subgroup
  auto _close_subgroup = _make_close_subgroup(group);

  // functor to find if any orbit contains a particular subgroup
  auto _subgroup_count = _make_subgroup_count(all_subgroups);

  auto all_subgroups_it = all_subgroups.begin();
  while (all_subgroups_it != all_subgroups.end()) {
    for (auto const &small_subgroups_orbit : small_subgroups) {
      for (auto const &small_subgroups_equiv : small_subgroups_orbit) {
        // Combine an existing subgroup and a small (cyclic) subgroup
        SubgroupIndices subgroup = *(all_subgroups_it->begin());
        Index init_size = subgroup.size();
        subgroup.insert(small_subgroups_equiv.begin(),
                        small_subgroups_equiv.end());
        if (subgroup.size() == init_size) continue;

        // Find group closure
        _close_subgroup(subgroup);

        // If subgroup already exists in all_subgroups, continue
        if (_subgroup_count(subgroup)) continue;

        // Else, make orbit and insert
        all_subgroups.insert(_make_subgroup_orbit(group, subgroup));
      }
    }
    ++all_subgroups_it;
  }
  return all_subgroups;
}

}  // namespace basic_symmetry
}  // namespace CASM

#endif
